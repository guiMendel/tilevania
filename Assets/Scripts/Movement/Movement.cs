using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public abstract class Movement : MonoBehaviour
{
  //=== Params
  [Tooltip("Whether to invert the direction the character faces")]
  [SerializeField] bool invertFacingDirection;

  [Header("Movement")]
  [Tooltip("The base speed in which the character moves")]
  public float baseSpeed = 5f;

  [Tooltip("How much inertia affects changes to the direction")]
  [Range(0f, 1f)] public float inertia = 0f;


  //=== State

  // Stores how much movement was applied in this frame
  Vector2 frameMovement;

  // Stores how much movement was applied last frame
  Vector2 lastFrameMovement;


  //=== Refs
  protected Rigidbody2D _rigidbody;

  private void Awake()
  {
    // Get components
    _rigidbody = GetComponent<Rigidbody2D>();

    OnAwake();
  }

  private void LateUpdate()
  {
    lastFrameMovement = frameMovement;
    frameMovement = Vector2.zero;
  }

  private void UpdateFacingDirection(Vector2 movement)
  {
    // Ignore small movements
    if (Mathf.Abs(movement.magnitude) <= 0.1f) return;

    // Get movement angle
    float movementAngle = Mathf.Acos(movement.normalized.x) * Mathf.Rad2Deg;

    // Keep facing direction updated
    SetFacingDirection(movementAngle < 90 ? 1 : -1);
  }


  //=== Overridables

  // How the movement actually occurs
  protected abstract void MoveTowards(Vector2 movementWithInertia, Vector2 originalMovement);

  // How to apply inertia to movement
  protected virtual Vector2 ApplyInertia(Vector2 movement)
  {
    // Apply inertia
    Vector2 currentMovement = _rigidbody.velocity;
    return (inertia * currentMovement) + ((1f - inertia) * movement);
  }

  // Sets the inertia
  public virtual void SeInertia(float newValue)
  {
    inertia = newValue;
  }

  // Hooks
  protected virtual void OnAwake() { }


  //=== Interface

  // THe magnitude of the direction parameter can be used to modify movement speed
  public void Move(Vector2 movement, bool faceMovementDirection = true)
  {
    // Update facing direction
    if (faceMovementDirection && movement != Vector2.zero) UpdateFacingDirection(movement);

    // Apply inertia
    frameMovement = ApplyInertia(baseSpeed * movement);

    MoveTowards(frameMovement, movement);
  }

  // Informs how much movement was generated by the Move method in the last frame
  public Vector2 GetLastFrameMovement()
  {
    return lastFrameMovement;
  }

  // Update facing direction
  public void SetFacingDirection(float direction)
  {
    float directionModifier = invertFacingDirection ? -1 : 1;
    transform.localScale = new Vector2(Mathf.Sign(direction) * directionModifier, 1f);
  }

  // Which direction is being faced
  public float GetFacingDirection()
  {
    return invertFacingDirection ? -transform.localScale.x : transform.localScale.x;
  }
}
